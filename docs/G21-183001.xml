<?xml version="1.0" encoding="UTF-8"?>
<modsCollection xmlns="http://www.loc.gov/mods/v3">
<mods ID="Svajlenko-2021-The">
    <titleInfo>
        <title>The Mutation and Injection Framework: Evaluating Clone Detection Tools with Mutation Analysis</title>
    </titleInfo>
    <name type="personal">
        <namePart type="given">Jeffrey</namePart>
        <namePart type="family">Svajlenko</namePart>
        <role>
            <roleTerm authority="marcrelator" type="text">author</roleTerm>
        </role>
    </name>
    <name type="personal">
        <namePart type="given">Chanchal</namePart>
        <namePart type="given">K</namePart>
        <namePart type="family">Roy</namePart>
        <role>
            <roleTerm authority="marcrelator" type="text">author</roleTerm>
        </role>
    </name>
    <originInfo>
        <dateIssued>2021</dateIssued>
    </originInfo>
    <typeOfResource>text</typeOfResource>
    <genre authority="bibutilsgt">journal article</genre>
    <relatedItem type="host">
        <titleInfo>
            <title>IEEE Transactions on Software Engineering, Volume 47, Issue 5</title>
        </titleInfo>
        <originInfo>
            <issuance>continuing</issuance>
            <publisher>Institute of Electrical and Electronics Engineers (IEEE)</publisher>
        </originInfo>
        <genre authority="marcgt">periodical</genre>
        <genre authority="bibutilsgt">academic journal</genre>
    </relatedItem>
    <abstract>An abundant number of clone detection tools have been proposed in the literature due to the many applications and benefits of clone detection. However, there has been difficulty in the performance evaluation and comparison of these clone detectors. This is due to a lack of reliable benchmarks, and the manual efforts required to validate a large number of candidate clones. In particular, there has been a lack of a synthetic benchmark that can precisely and comprehensively measure clone-detection recall. In this paper, we present a mutation-analysis based benchmarking framework that can be used not only to evaluate the recall of clone detection tools for different types of clones but also for specific kinds of clone edits and without any manual efforts. The framework uses an editing taxonomy of clone synthesis for generating thousands of artificial clones, injects into code bases and automatically evaluates the subject clone detection tools following the mutation analysis approach. Additionally, the framework has features where custom clone pairs could also be used in the framework for evaluating the subject tools. This gives the opportunity of evaluating specialized tools for specialized contexts such as evaluating a tool’s capability for the detection of complex Type-4 clones or real world clones without writing complex mutation operators for them. We demonstrate this framework by evaluating the performance of ten modern clone detection tools across two clone granularities (function and block) and three programming languages (Java, C and C#). Furthermore, we provide a variant of the framework that can be used to evaluate specialized tools such as for large gaped clone detection. Our experiments demonstrate confidence in the accuracy of our Mutation and Injection Framework when comparing against the expected results of the corresponding tools, and widely used real-world benchmarks such as Bellon’s benchmark and BigCloneBench. We provide features so that most clone detection tools that report clones in the form of clone pairs (either in filename/line numbers or filename/tokens) could be evaluated using the framework.</abstract>
    <identifier type="citekey">Svajlenko-2021-The</identifier>
    <identifier type="doi">10.1109/tse.2019.2912962</identifier>
    <location>
        <url>https://aclanthology.org/G21-183001</url>
    </location>
    <part>
        <date>2021</date>
        <detail type="volume"><number>47</number></detail>
        <detail type="issue"><number>5</number></detail>
        <extent unit="page">
            <start>1060</start>
            <end>1087</end>
        </extent>
    </part>
</mods>
</modsCollection>
